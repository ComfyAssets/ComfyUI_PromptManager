<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>PromptManager â€” Metadata Extractor</title>
    <link rel="stylesheet" href="/prompt_manager/css/style.css" />
    <link rel="stylesheet" href="/prompt_manager/css/blue-theme-update.css" />
    <link rel="stylesheet" href="/prompt_manager/css/components.css" />
    <link rel="stylesheet" href="/prompt_manager/css/metadata.css" />
    <link rel="stylesheet" href="/prompt_manager/css/notifications.css" />
    <link rel="stylesheet" href="/prompt_manager/css/migration.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
      integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <!-- ViewerJS CSS -->
    <link rel="stylesheet" href="/prompt_manager/vendor/viewerjs/dist/viewer.min.css" />

</head>
  <body x-data="pmMetaApp()" x-init="init()">
    <div class="app-container">
      <!-- Sidebar -->
      <aside class="sidebar">
        <div class="sidebar-header">
          <div id="brand-badge" class="brand-badge">PM</div>
          <div>
            <div class="sidebar-header-title">PromptManager</div>
            <div class="sidebar-header-subtitle">
              Professional Suite
            </div>
          </div>
        </div>

                                                <nav class="nav-menu">
          <a href="/prompt_manager/" class="nav-item">
            <i class="fa-solid fa-house nav-icon" aria-hidden="true"></i>
            <span>Home</span>
          </a>
          <a href="/prompt_manager/dashboard" class="nav-item">
            <i class="fa-solid fa-chart-line nav-icon" aria-hidden="true"></i>
            <span>Dashboard</span>
          </a>
          <a href="/prompt_manager/gallery" class="nav-item">
            <i class="fa-solid fa-images nav-icon" aria-hidden="true"></i>
            <span>Gallery</span>
          </a>
          <a href="/prompt_manager/collections" class="nav-item">
            <i class="fa-solid fa-folder-tree nav-icon" aria-hidden="true"></i>
            <span>Collections</span>
          </a>
          <a href="/prompt_manager/stats" class="nav-item">
            <i class="fa-solid fa-chart-column nav-icon" aria-hidden="true"></i>
            <span>Stats</span>
          </a>
          <a href="/prompt_manager/metadata" class="nav-item active">
            <i class="fa-solid fa-tags nav-icon" aria-hidden="true"></i>
            <span>Metadata</span>
          </a>
          <a href="/prompt_manager/settings" class="nav-item">
            <i class="fa-solid fa-gear nav-icon" aria-hidden="true"></i>
            <span>Settings</span>
          </a>
          <a href="/prompt_manager/logs" class="nav-item">
            <i class="fa-solid fa-clipboard-list nav-icon" aria-hidden="true"></i>
            <span>Logs</span>
          </a>
        </nav>
      </aside>

      <!-- Main Content -->
      <main class="main-content">
        <!-- Topbar -->
        <div class="topbar">
          <div class="search-container">
            <input
              type="text"
              placeholder="Search metadata..."
              class="search-input"
            />
          </div>
          <div class="topbar-actions">
            <button class="btn btn-ghost">
              <span><i class="fa-regular fa-bell" aria-hidden="true"></i></span>
            </button>
            <button class="btn btn-ghost">
              <span><i class="fa-solid fa-gear" aria-hidden="true"></i></span>
            </button>
          </div>
        </div>

        <!-- Page Content -->
        <div class="page-content">
          <div class="page-header">
            <div>
              <h1>Metadata Extractor</h1>
              <p>Extract ComfyUI workflow data from PNG images</p>
            </div>
          </div>

          <!-- Drop Zone -->
          <section :class="['drop-zone', drag ? 'drag' : '', thumb ? 'small' : 'large']" @dragover.prevent="drag=true" @dragleave="drag=false" @drop.prevent="handleDrop($event)">
            <div class="drop-zone-content">
              <div class="drop-zone-icon">ðŸ“Ž</div>
              <div class="drop-zone-text">
                Drag & drop image (PNG/JPEG/WEBP) or
              </div>
              <input id="pick" type="file" accept="image/*" class="file-input-hidden" @change="filePicked" />
              <button class="btn btn-primary" @click="document.getElementById('pick').click()">
                Choose File
              </button>
            </div>
          </section>

          <!-- Image and Prompts -->
          <template x-if="thumb">
            <div class="metadata-grid">
              <div class="card">
                <h3 class="card-title">Image Preview</h3>
                <img class="preview" :src="thumb" alt="preview" />
                <div class="file-info">
                  <span x-text="fileName"></span> â€¢
                  <span x-text="fileType"></span> â€¢
                  <span x-text="(fileSize/1024).toFixed(1) + ' KB'"></span>
                </div>
              </div>

              <div class="card">
                <div class="section-header">
                  <h3 class="section-title">Extracted Prompts</h3>
                  <div class="btn-actions">
                    <button class="btn btn-secondary btn-sm" @click="copy(texts.positive)">
                      Copy Positive
                    </button>
                    <button class="btn btn-secondary btn-sm" @click="copy(texts.negative)">
                      Copy Negative
                    </button>
                  </div>
                </div>

                <div class="prompt-section">
                  <div class="prompt-indicator">
                    <div class="indicator-dot-brand"></div>
                    <strong>Positive Prompt</strong>
                  </div>
                  <pre x-text="texts.positive || '(none found)'"></pre>
                </div>

                <div>
                  <div class="prompt-indicator">
                    <div class="indicator-dot-pink"></div>
                    <strong>Negative Prompt</strong>
                  </div>
                  <pre x-text="texts.negative || '(none found or not used by this model)'"></pre>
                </div>
              </div>
            </div>
          </template>

          <!-- Workflow and Raw Data -->
          <template x-if="workflow || raw">
            <div class="metadata-grid">
              <div class="card">
                <div class="section-header">
                  <h3 class="section-title">Workflow Data</h3>
                  <button class="btn btn-secondary btn-sm" @click="copy(workflow)">
                    Copy JSON
                  </button>
                </div>
                <pre x-text="workflow || '(none found)'"></pre>
              </div>

              <div class="card">
                <div class="section-header">
                  <h3 class="section-title">Raw Metadata</h3>
                  <button class="btn btn-secondary btn-sm" @click="downloadRaw">
                    Download JSON
                  </button>
                </div>
                <pre x-text="raw"></pre>
              </div>
            </div>
          </template>

          <!-- Empty State -->
          <div x-show="!thumb && !workflow && !raw" class="empty-state-metadata">
            <div class="empty-state-icon-large"><i class="fa-solid fa-tags" aria-hidden="true"></i></div>
            <h3 class="empty-state-title">No Image Selected</h3>
            <p class="empty-state-text">Upload an image to extract its metadata and workflow information</p>
          </div>
        </div>
      </main>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2/dist/pako.min.js"></script>
    <script>
      (function () {
        const PNG_SIGNATURE = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];

        function parsePossibleParams(input) {
          const result = { positive: '', negative: '' };
          if (!input) return result;
          const lines = String(input).split(/\r?\n/);

          const firstLine = (lines[0] || '').replace(/^prompt[: ]*/i, '').trim();
          if (firstLine) {
            result.positive = firstLine;
          }

          const negativeLine = lines.find((line) => /negative prompt/i.test(line));
          if (negativeLine) {
            result.negative = negativeLine.replace(/negative prompt[: ]*/i, '').trim();
          }

          return result;
        }

        function detectType(buffer) {
          const bytes = new Uint8Array(buffer);
          const isPng = PNG_SIGNATURE.every((byte, idx) => bytes[idx] === byte);
          if (isPng) return 'image/png';
          const isJpeg = bytes[0] === 0xff && bytes[1] === 0xd8;
          if (isJpeg) return 'image/jpeg';
          return 'application/octet-stream';
        }

        async function parsePngChunks(arrayBuffer) {
          const dataView = new DataView(arrayBuffer);
          const result = {};
          if (dataView.getUint32(0) !== 0x89504e47) {
            return result;
          }

          let offset = 8;
          const decoder = new TextDecoder('utf-8');

          while (offset < dataView.byteLength) {
            const length = dataView.getUint32(offset);
            const type = String.fromCharCode(
              dataView.getUint8(offset + 4),
              dataView.getUint8(offset + 5),
              dataView.getUint8(offset + 6),
              dataView.getUint8(offset + 7)
            );
            const chunk = new Uint8Array(arrayBuffer, offset + 8, length);
            offset += length + 12;

            if (type === 'tEXt') {
              const separator = chunk.indexOf(0);
              if (separator > 0) {
                const key = decoder.decode(chunk.slice(0, separator));
                const value = decoder.decode(chunk.slice(separator + 1));
                result[key] = value;
              }
            } else if (type === 'iTXt') {
              let index = 0;
              const readNullTerminated = () => {
                const end = chunk.indexOf(0, index);
                const value = decoder.decode(chunk.slice(index, end));
                index = end + 1;
                return value;
              };
              const keyword = readNullTerminated();
              const compressed = chunk[index++];
              index++; // compression method
              readNullTerminated(); // language tag
              readNullTerminated(); // translated keyword
              const textBytes = chunk.slice(index);

              if (compressed === 1 && typeof pako !== 'undefined') {
                try {
                  result[keyword] = decoder.decode(pako.inflate(textBytes));
                } catch (error) {
                  console.warn('Failed to inflate iTXt chunk', error);
                  result[keyword] = decoder.decode(textBytes);
                }
              } else {
                result[keyword] = decoder.decode(textBytes);
              }
            } else if (type === 'zTXt' && typeof pako !== 'undefined') {
              let index = 0;
              const separator = chunk.indexOf(0, index);
              const keyword = decoder.decode(chunk.slice(0, separator));
              index = separator + 2; // skip null + compression method
              try {
                result[keyword] = decoder.decode(pako.inflate(chunk.slice(index)));
              } catch (error) {
                console.warn('Failed to inflate zTXt chunk', error);
              }
            }

            if (type === 'IEND') break;
          }

          return result;
        }

        function formatWorkflow(value) {
          if (!value) return '';
          if (typeof value === 'string') {
            const trimmed = value.trim();
            if (!trimmed) return '';
            try {
              const parsed = JSON.parse(trimmed);
              return JSON.stringify(parsed, null, 2);
            } catch {
              return trimmed;
            }
          }
          try {
            return JSON.stringify(value, null, 2);
          } catch {
            return String(value);
          }
        }

        function safeStringify(value) {
          if (value === undefined || value === null) {
            return '';
          }
          try {
            return JSON.stringify(value, null, 2);
          } catch (error) {
            console.warn('Failed to stringify metadata', error);
            return String(value);
          }
        }

        function ensureMetadataManagerReady() {
          if (window.MetadataManager?.init && !window.__pmMetadataManagerReady) {
            window.MetadataManager.init({ enableCache: false });
            window.__pmMetadataManagerReady = true;
          }
        }

        window.pmMetaApp = function () {
          return {
            drag: false,
            thumb: '',
            fileName: '',
            fileSize: 0,
            fileType: '',
            metadata: null,
            texts: { positive: '', negative: '' },
            workflow: '',
            raw: '',
            error: null,
            init() {
              ensureMetadataManagerReady();
            },
            async handleDrop(event) {
              this.drag = false;
              const file = event.dataTransfer.files?.[0];
              if (file) {
                await this.processFile(file);
              }
            },
            async filePicked(event) {
              const file = event.target.files?.[0];
              if (file) {
                await this.processFile(file);
                event.target.value = '';
              }
            },
            async processFile(file) {
              this.error = null;
              this.metadata = null;
              this.texts = { positive: '', negative: '' };
              this.workflow = '';
              this.raw = '';
              if (this.thumb) {
                URL.revokeObjectURL(this.thumb);
              }
              this.thumb = URL.createObjectURL(file);
              this.fileName = file.name;
              this.fileSize = file.size;
              this.fileType = file.type || '';

              ensureMetadataManagerReady();
              const handled = await this.tryMetadataManager(file);
              if (!handled) {
                await this.extractWithFallback(file);
              }
            },
            async tryMetadataManager(file) {
              if (!window.MetadataManager || typeof window.MetadataManager.extract !== 'function') {
                return false;
              }
              try {
                const metadata = await window.MetadataManager.extract(file, false);
                if (!metadata) {
                  return false;
                }
                this.applyMetadata(metadata);
                return true;
              } catch (error) {
                console.error('MetadataManager.extract failed', error);
                this.error = error?.message || String(error);
                return false;
              }
            },
            applyMetadata(metadata) {
              this.metadata = metadata;
              const standard = metadata.standard || {};
              if (standard.filename) {
                this.fileName = standard.filename;
              }
              if (typeof standard.fileSize === 'number') {
                this.fileSize = standard.fileSize;
              }
              if (standard.mimeType) {
                this.fileType = standard.mimeType;
              }

              const paramsSource = metadata.custom?.parameters ?? metadata.custom?.Parameter ?? metadata.parameters ?? '';
              const prompts = parsePossibleParams(paramsSource);
              const positive = metadata.custom?.prompt ?? metadata.custom?.positivePrompt ?? metadata.prompt ?? prompts.positive ?? '';
              const negative = metadata.custom?.negativePrompt ?? metadata.negativePrompt ?? prompts.negative ?? '';
              this.texts = { positive: positive || '', negative: negative || '' };

              const workflowCandidate =
                metadata.custom?.workflow ??
                metadata.custom?.Workflow ??
                metadata.custom?.['workflow-json'] ??
                metadata.custom?.workflow_json ??
                metadata.workflow ??
                metadata['sd-metadata'];
              this.workflow = formatWorkflow(workflowCandidate);

              const rawSource = metadata.raw && Object.keys(metadata.raw).length ? metadata.raw : metadata;
              this.raw = safeStringify(rawSource);
            },
            async extractWithFallback(file) {
              try {
                const buffer = await file.arrayBuffer();
                let type = (file.type && file.type.toLowerCase()) || detectType(buffer);
                if (!type || type === 'application/octet-stream') {
                  type = detectType(buffer);
                }

                if (type === 'image/png') {
                  const chunks = await parsePngChunks(buffer);
                  this.raw = safeStringify(chunks);
                  const params = chunks.parameters || chunks.Parameter || chunks.parametersTxt || '';
                  const parsed = parsePossibleParams(params);
                  const prompt = chunks.prompt || chunks.Prompt || '';
                  const negative = chunks['negative_prompt'] || chunks.Negative || '';
                  this.texts = {
                    positive: parsed.positive || prompt,
                    negative: parsed.negative || negative
                  };
                  this.workflow = formatWorkflow(
                    chunks.workflow ||
                    chunks.Workflow ||
                    chunks['sd-metadata']
                  );
                } else if (type === 'image/jpeg' || type === 'image/jpg') {
                  const exif = await this.extractJpegExif(buffer);
                  this.raw = safeStringify(exif);
                  const prompts = parsePossibleParams(exif.UserComment || exif.ImageDescription || '');
                  this.texts = {
                    positive: prompts.positive,
                    negative: prompts.negative
                  };
                } else {
                  this.raw = '(unknown image format for metadata)';
                }

                this.fileType = type;
                this.fileSize = buffer.byteLength;
              } catch (error) {
                console.error('Fallback metadata extraction failed', error);
                this.raw = '(metadata extraction failed)';
              }
            },
            async extractJpegExif(buffer) {
              if (typeof EXIF === 'undefined') {
                return {};
              }
              try {
                if (typeof EXIF.readFromBinaryFile === 'function') {
                  return EXIF.readFromBinaryFile(buffer) || {};
                }
              } catch (error) {
                console.warn('EXIF parsing failed', error);
              }
              return {};
            },
            copy(text) {
              const value = text || '';
              if (navigator.clipboard && value) {
                navigator.clipboard.writeText(value);
              }
              if (window.showToast) {
                window.showToast('Copied!', 'success');
              } else {
                console.log('[Copied]', value);
              }
            },
            downloadRaw() {
              const payload = typeof this.raw === 'string' ? this.raw : safeStringify(this.raw);
              const blob = new Blob([payload || '{}'], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const anchor = document.createElement('a');
              anchor.href = url;
              anchor.download = 'metadata.json';
              anchor.click();
              URL.revokeObjectURL(url);
            }
          };
        };
      })();
    </script>

    <!-- ViewerJS Library -->
    <script src="/prompt_manager/vendor/viewerjs/dist/viewer.min.js"></script>

    <!-- Core modules -->
    <script src="/prompt_manager/js/modules/core/events.js"></script>
    <script src="/prompt_manager/js/modules/core/sse.js"></script>

    <!-- SSE Indicators -->
    <script src="/prompt_manager/js/modules/components/status-indicator.js"></script>
    <script src="/prompt_manager/js/modules/components/progress-indicator.js"></script>
    <script src="/prompt_manager/js/modules/components/footer-status.js"></script>

    <!-- ViewerJS Modules -->
    <script src="/prompt_manager/js/modules/components/viewer-manager.js"></script>
    <script src="/prompt_manager/js/modules/components/filmstrip-manager.js"></script>
    <script src="/prompt_manager/js/modules/services/metadata-manager.js"></script>

        <script src="/prompt_manager/js/modules/core/viewer-integration.js"></script>

        <!-- Existing scripts -->
        <script src="/prompt_manager/js/notifications.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Footer -->
    <footer class="main-footer">
      <div class="footer-content">
        <div class="footer-text">
          PromptManager â€” Clean, Fast, Local. Â© 2025
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">Documentation</a>
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">Support</a>
        </div>
      </div>
    </footer>
  </body>
  </html>